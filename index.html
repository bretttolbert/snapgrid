<!DOCTYPE html>
<html>
<head>
<title>snapgrid</title>
<meta charset="utf-8" />
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
<script type="text/javascript">
/**
 * snapgrid
 * https://github.com/bretttolbert/snapgrid
 */
 //snapgrid global variables
var canvas; //html5 canvas element
var ctx; //canvas drawing context
var CELL_SIZE = 16; //size of each grid cell
var mouseX, mouseY; //coordinate of most recent mouse position
var snapX, snapY; //coordinate of grid vertex which is closest to cursor position
var lineSegments = []; //the list of all existing line segments (point pairs)
var currentTool = 'line-tool';
var isGridVisible = true;
var snapToGrid = true;
var snapToVertices = true;
var snapToEdges = false;

//line-tool variables
var pendingLineStartPoint = null; //used by the line-tool

function isPointOnLineSegment(lineSeg, point, tolerance) {
    //calculate slope of the line, in case of vertical line divide by zero like a boss
    var m = (lineSeg.p2.y - lineSeg.p1.y)
          / (lineSeg.p2.x - lineSeg.p1.x);
    var x,y;
    if (Math.abs(m) == Infinity) {
        x = point.x;
        y = point.y;
    } else {
        //calculate what y of the line would be if x were exactly point.x
        y = m * (point.x - lineSeg.p1.x) + lineSeg.p1.y;
        //calculate what x of the line would be if y were exactly point.y
        x = (point.y - lineSeg.p1.y) / m + lineSeg.p1.x;
    }
    //are calculated values within tolerance?
    if (Math.abs(y - point.y) < tolerance && Math.abs(y - point.y) < tolerance) {
        //point is (approximately) on the line but is it within the line segment?
        //determine extrema of the line segment
        var minX = Math.min(lineSeg.p1.x, lineSeg.p2.x);
        var minY = Math.min(lineSeg.p1.y, lineSeg.p2.y);
        var maxX = Math.max(lineSeg.p1.x, lineSeg.p2.x);
        var maxY = Math.max(lineSeg.p1.y, lineSeg.p2.y);
        if (   (point.x >= minX || minX - point.x < tolerance)
            && (point.y >= minY || minY - point.y < tolerance)
            && (point.x <= maxX || point.x - maxX < tolerance)
            && (point.y <= maxY || point.y - maxY < tolerance)) {
            return true;
        }
    }
    return false;
}

/** 
 * Responsible for drawing the grid and all existing line segments
 */
function drawGrid() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (isGridVisible) {
        ctx.strokeStyle = '#ddd';
        for (var x=CELL_SIZE; x<canvas.width; x+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,canvas.height);
            ctx.stroke();
        }
        for (var y=CELL_SIZE; y<canvas.width; y+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(canvas.width,y);
            ctx.stroke();
        }
    }
    for (var i=0; i<lineSegments.length; ++i) {
        var p1 = lineSegments[i].p1;
        var p2 = lineSegments[i].p2;

        //draw dot for p1
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();
        
        //draw dot for p2
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();
        
        //draw line
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y)
        ctx.lineTo(p2.x, p2.y);
        if (lineSegments[i].hover && (currentTool == 'delete-tool' || currentTool == 'select-tool')) {
            ctx.strokeStyle = 'teal';
        } else if (lineSegments[i].selected) {
            ctx.strokeStyle = 'blue';
        } else {
            ctx.strokeStyle = 'black';
        }
        ctx.stroke();
    }
}

/**
 * Detects mouse hover over any existing line segment
 */
function updateMouseHoverLine() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSeg = lineSegments[i];
        //determine if cursor position is on or very near a line
        var TOLERANCE = CELL_SIZE/2;
        if (isPointOnLineSegment(lineSeg, {x:mouseX,y:mouseY}, TOLERANCE)) {
            lineSeg.hover = true;
        } else {
            lineSeg.hover = false;
        }
    }
}

/**
 * Determines grid vertex closest to mouse position
 */
function updateSnapPos() {
    snapX = mouseX;
    snapY = mouseY;
    if (snapToGrid) {
        //determine first vertical gridline with x greater than mouseX
        for (snapX=CELL_SIZE; snapX<=canvas.width && snapX<mouseX; snapX+=CELL_SIZE) { }
        //snap to previous vertical gridline if mouseX is less than half way there
        if ((snapX - mouseX) > CELL_SIZE / 2) {
            snapX -= CELL_SIZE;
        }

        //determine first horizontal gridline with y greater than mouseY
        for (snapY=CELL_SIZE; snapY<=canvas.height && snapY<mouseY; snapY+=CELL_SIZE) { }
        //snap to previous horizontal gridline if mouseY is less than half way there
        if ((snapY - mouseY) > CELL_SIZE / 2) {
            snapY -= CELL_SIZE;
        }
    }
    if (snapToVertices) {
        var TOLERANCE = CELL_SIZE / 2;
        for (var i=0; i<lineSegments.length; ++i) {
            //if mouse position is within TOLERANCE distance of one vertex of a line exactly
            if ( Math.abs(mouseX - lineSegments[i].p1.x) < TOLERANCE 
              && Math.abs(mouseY - lineSegments[i].p1.y) < TOLERANCE) {
                snapX = lineSegments[i].p1.x;
                snapY = lineSegments[i].p1.y;
                return;
            } else if ( Math.abs(mouseX - lineSegments[i].p2.x) < TOLERANCE
                     && Math.abs(mouseY - lineSegments[i].p2.y) < TOLERANCE) {
                snapX = lineSegments[i].p2.x;
                snapY = lineSegments[i].p2.y;
                return;
            }
        }
    }
}

function mouseMove(e) {
    if(e.offsetX) {
        mouseX = e.offsetX;
        mouseY = e.offsetY;
    }
    else if(e.layerX) {
        mouseX = e.layerX;
        mouseY = e.layerY;
    }
    drawGrid();
    updateSnapPos();
    updateMouseHoverLine();
    
    if (currentTool == 'line-tool') {    
        //draw dot at target position
        ctx.beginPath();
        ctx.arc(snapX, snapY, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = 'teal';
        ctx.fill();
        
        //if there is a pending line
        if (pendingLineStartPoint != null) {
            //draw temporary line from pendingLineStartPoint to target position
            ctx.beginPath();
            ctx.moveTo(pendingLineStartPoint.x, pendingLineStartPoint.y);
            ctx.lineTo(snapX, snapY);
            ctx.closePath();
            ctx.strokeStyle = 'teal';
            ctx.stroke();
        }
    } else if (currentTool == 'delete-tool') {
        
    } else if (currentTool == 'select-tool') {
        
    }
}

function mouseClick(e) {
    if (currentTool == 'line-tool') {
        if (pendingLineStartPoint != null) {
            //complete pending line
            lineSegments.push({
                p1:pendingLineStartPoint,
                p2:{x:snapX,y:snapY},
                selected:false,
                hover:false}
            );
        }
        //start pending line
        pendingLineStartPoint = {x:snapX,y:snapY};
    } else if (currentTool == 'delete-tool') {
        //delete mouse hover line
        var mouseHoverLine = -1;
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                mouseHoverLine = i;
                break;
            }
        }
        if (mouseHoverLine != -1) {
            lineSegments.splice(mouseHoverLine,1);     
        }
    } else if (currentTool == 'select-tool') {
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                lineSegments[i].selected = !lineSegments[i].selected;
                lineSegments[i].hover = false;
            }
        }
    }
    drawGrid();
}

function mouseDown(e) {
	var rightclick;
	if (!e) var e = window.event;
	if (e.which) rightclick = (e.which == 3);
	else if (e.button) rightclick = (e.button == 2);
	alert('Rightclick: ' + rightclick); // true or false
}

function rightClick() {
    if (currentTool == 'line-tool') {
        //clear pending line
        pendingLineStartPoint = null;
    }
}

function clickIE() {
    if (document.all) {
        return false;
    }
} 
function clickNS(e) {
    if (document.layers || (document.getElementById && !document.all)) 
    { 
        if (e.which==2 || e.which==3) {
            rightClick();
            return false;
        }
    }
}
if (document.layers) {
    document.captureEvents(Event.MOUSEDOWN);
    document.onmousedown = clickNS;
} else {
    document.onmouseup = clickNS;
    document.oncontextmenu = clickIE;
}
document.oncontextmenu = function() {return false;};

function showHideGridBtnClicked() {
    if ($(this).val() == "Hide Grid") {
        isGridVisible = false;
        $(this).val("Show Grid");
    } else {
        isGridVisible = true;
        $(this).val("Hide Grid");
    }
    drawGrid();
}

function selectAllBtnClicked() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSegments[i].selected = true;
    }
    drawGrid();
}

function selectNoneBtnClicked() {
    clearSelectedLines();
    drawGrid();
}

function deleteSelectedBtnClicked() {
    var survivingLines = [];
    for (var i=0; i<lineSegments.length; ++i) {
        if (!lineSegments[i].selected) {
            survivingLines.push(lineSegments[i]);
        }
    }
    lineSegments = survivingLines;
    drawGrid();
}

function clearSelectedLines() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSegments[i].selected = false;
    }    
}

function toolRadioChanged() {
    var id = this.id;
    currentTool = id;
    pendingLineStartPoint = null;
    if (id == 'delete-tool' || id == 'line-tool') {
        //clearSelectedLines(); //not sure if this is desirable
    }
    drawGrid();
}

function initSnapOptionsUI() {
    //$("#snapOptions").buttonset();
    $("#snapToGrid").prop('checked',snapToGrid);
    $("#snapToVertices").prop('checked',snapToVertices);
    $("#snapToEdges").prop('checked',snapToEdges);
    $("#snapToGrid").change(function() {
        snapToGrid = $(this).prop('checked');
    });
    $("#snapToVertices").change(function() {
        snapToVertices = $(this).prop('checked');
    });
    $("#snapToEdges").change(function() {
        alert('Not Implemented');
        snapToEdges = $(this).prop('checked');
    });
}

$(function() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    drawGrid();
    canvas.addEventListener('mousemove', mouseMove, false);
    canvas.addEventListener('click', mouseClick, false);
    //$('input.Btn').button();
    $('#showHideGridBtn').click(showHideGridBtnClicked);
    $('#selectAllBtn').click(selectAllBtnClicked);
    $('#selectNoneBtn').click(selectNoneBtnClicked);
    $('#deleteSelectedBtn').click(deleteSelectedBtnClicked);
    //$("#radio").buttonset();
    $("input.ToolRadio").change(toolRadioChanged);
    initSnapOptionsUI();
});
</script>
<style type="text/css">
#canvas {
    border: 1px solid #ddd;
    position: relative;
}
input.BtnSelected {
    background-color: #888;
}
input, label {
    font-family: Calibri;
}
</style>
</head>
<body>
<div style="text-align: center">
<canvas id="canvas" width="640" height="480"></canvas>
<form>
	<div id="radio">
		<input type="radio" class="ToolRadio" name="tool-radio" id="line-tool" checked="checked" /><label for="line-tool">Line Tool</label>
		<input type="radio" class="ToolRadio" name="tool-radio" id="select-tool" /><label for="select-tool">Select Tool</label>
        <input type="radio" class="ToolRadio" name="tool-radio" id="delete-tool" /><label for="delete-tool">Delete Tool</label>
	</div>
    <input type="button" class="Btn" value="Hide Grid" id="showHideGridBtn"/>
    <input type="button" class="Btn" value="Select All" id="selectAllBtn"/>
    <input type="button" class="Btn" value="Select None" id="selectNoneBtn"/>
    <input type="button" class="Btn" value="Delete Selected" id="deleteSelectedBtn"/>
    <div id="snapOptions">
        <input type="checkbox" id="snapToGrid" /><label for="snapToGrid">Snap to Grid</label>
        <input type="checkbox" id="snapToVertices" /><label for="snapToVertices">Snap to Vertices</label>
        <input type="checkbox" id="snapToEdges" /><label for="snapToEdges">Snap to Edges</label>
    </div>
</form>
</div>
</body>
</html>