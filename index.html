<!DOCTYPE html>
<html>
<head>
<title>snapgrid</title>
<meta charset="utf-8" />
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
<script src="js/Geometry.js"></script>
<script type="text/javascript">
/**
 * snapgrid
 * https://github.com/bretttolbert/snapgrid
 */
 //snapgrid global variables
var canvas; //html5 canvas element
var ctx; //canvas drawing context
var CELL_SIZE = 16; //size of each grid cell
var mouseX, mouseY; //coordinate of most recent mouse position
var snapX, snapY; //coordinate of grid vertex which is closest to cursor position
var snapType; //string describing what we have snapped to. Possible values: 'none', 'grid', 'vertex', 'edge' 
var lineSegments = []; //the list of all existing line segments (point pairs)
var currentTool = 'draw-line';
var isGridVisible = true;
var drawVertexDots = false; //draw dots on every vertex
var snapToGrid = true;
var snapToVertices = true;
var snapToEdges = true;
var DEBUG = false;
var selectedVertex = null; //used by move-vertex tool
var history = []; //used for Undo/Redo (Ctrl-Z/Ctrl-Y)
var ctrlDown = false;
var KEY_CTRL=17, KEY_C=67, KEY_V=86, KEY_Y=89, KEY_Z=90;

//draw-line variables
var pendingLineStartPoint = null; //used by the draw-line

/**
 * All tools are required to call this function before modifying the contents of the grid
 * (e.g. before adding a new line segment or before moving a vertex)
 * Saves the state of the grid into history for retrieval via Undo button or Ctrl-Z
 */
function saveGrid() {
    var snapshot = [];
    for (var i=0; i<lineSegments.length; ++i) {
        snapshot.push({p1:{x:lineSegments[i].p1.x,y:lineSegments[i].p1.y},p2:{x:lineSegments[i].p2.x,y:lineSegments[i].p2.y}});
    }
    history.push({'lineSegments':snapshot});
}

/** 
 * Responsible for drawing the grid and all existing line segments
 */
function drawGrid() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (isGridVisible) {
        ctx.strokeStyle = '#ddd';
        for (var x=CELL_SIZE; x<canvas.width; x+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,canvas.height);
            ctx.stroke();
        }
        for (var y=CELL_SIZE; y<canvas.width; y+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(canvas.width,y);
            ctx.stroke();
        }
    }
    var src = '{lineSegments:[\n';
    for (var i=0; i<lineSegments.length; ++i) {
        var p1 = {x:lineSegments[i].p1.x, y:lineSegments[i].p1.y};
        var p2 = {x:lineSegments[i].p2.x, y:lineSegments[i].p2.y};
        
        //temporarily apply vertex translations for vertex move preview
        if (currentTool == 'move-vertex' && selectedVertex != null) {
            if (p1.x == selectedVertex.x && p1.y == selectedVertex.y) {
                p1.x = snapX;
                p1.y = snapY;
            } else if (p2.x == selectedVertex.x && p2.y == selectedVertex.y) {
                p2.x = snapX;
                p2.y = snapY;
            }
        }
        
        src += '{p1:{x:' + p1.x + ',y:' + p1.y + '},p2:{x:' + p2.x + ',y:' + p2.y + '}}';
        if (i != lineSegments.length-1) {
            src += ',';
        }
        src += '\n';
        
        if (drawVertexDots) {
            //draw dot for p1
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fillStyle = "black";
            ctx.fill();
            
            //draw dot for p2
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, 2, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fillStyle = "black";
            ctx.fill();
        }
        
        //draw line
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y)
        ctx.lineTo(p2.x, p2.y);
        if (lineSegments[i].hover && (currentTool == 'delete-line' || currentTool == 'select-line')) {
            ctx.strokeStyle = 'teal';
        } else if (lineSegments[i].selected) {
            ctx.strokeStyle = 'blue';
        } else {
            ctx.strokeStyle = 'black';
        }
        ctx.stroke();
    }
    src += ']}';
    $('#srcTxt').val(src);
}

/**
 * Detects mouse hover over any existing line segment
 */
function updateMouseHoverLine() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSeg = lineSegments[i];
        //determine if cursor position is on or very near a line
        var TOLERANCE = CELL_SIZE/2;
        var mousePos = {x:mouseX,y:mouseY};
        var closestPoint = Geometry.getClosestPointOnLineSegment(lineSeg.p1, lineSeg.p2, mousePos, TOLERANCE)
        if (closestPoint != false) {
            lineSeg.hover = true;
            if (DEBUG && currentTool == "select-line" || currentTool == "delete-line") {
                //draw dot for p2
                ctx.beginPath();
                ctx.arc(closestPoint.x, closestPoint.y, 2, 0, Math.PI*2, true); 
                ctx.closePath();
                ctx.fillStyle = "purple";
                ctx.fill();
            }
        } else {
            lineSeg.hover = false;
        }
    }
}

/**
 * Determines grid vertex closest to mouse position
 */
function updateSnapPos() {
    snapX = mouseX;
    snapY = mouseY;
    snapType = 'none';
    if (snapToGrid) {
        snapType = 'grid';
        //determine first vertical gridline with x greater than mouseX
        for (snapX=CELL_SIZE; snapX<=canvas.width && snapX<mouseX; snapX+=CELL_SIZE) { }
        //snap to previous vertical gridline if mouseX is less than half way there
        if ((snapX - mouseX) > CELL_SIZE / 2) {
            snapX -= CELL_SIZE;
        }

        //determine first horizontal gridline with y greater than mouseY
        for (snapY=CELL_SIZE; snapY<=canvas.height && snapY<mouseY; snapY+=CELL_SIZE) { }
        //snap to previous horizontal gridline if mouseY is less than half way there
        if ((snapY - mouseY) > CELL_SIZE / 2) {
            snapY -= CELL_SIZE;
        }
    }
    var TOLERANCE = CELL_SIZE / 2;
    var mousePos = {x:mouseX,y:mouseY};
    if (snapToVertices) {
        for (var i=0; i<lineSegments.length; ++i) {
            //if mouse position is within TOLERANCE distance of one vertex of a line exactly
            if (Geometry.distance(mousePos, lineSegments[i].p1) < TOLERANCE) {
                snapX = lineSegments[i].p1.x;
                snapY = lineSegments[i].p1.y;
                snapType = 'vertex';
                return;
            } else if (Geometry.distance(mousePos, lineSegments[i].p2) < TOLERANCE) {
                snapX = lineSegments[i].p2.x;
                snapY = lineSegments[i].p2.y;
                snapType = 'vertex';
                return;
            }
        }
    }
    //ToDo: implement snap to implicit vertices created by intersecting line segments
    if (snapToEdges) {
        for (var i=0; i<lineSegments.length; ++i) {
            var closestPoint = Geometry.getClosestPointOnLineSegment(lineSegments[i].p1, lineSegments[i].p2, mousePos, TOLERANCE)
            if (closestPoint != false) {
                snapX = closestPoint.x;
                snapY = closestPoint.y;
                snapType = 'edge';
                return;
            }
        }
    }
}

function mouseMove(e) {
    if(e.offsetX) {
        mouseX = e.offsetX;
        mouseY = e.offsetY;
    }
    else if(e.layerX) {
        mouseX = e.layerX;
        mouseY = e.layerY;
    }
    drawGrid();
    updateSnapPos();
    updateMouseHoverLine();
    
    if (currentTool == 'draw-line') {    
        //draw dot at snap position
        ctx.beginPath();
        ctx.arc(snapX, snapY, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = 'teal';
        ctx.fill();
        
        //if there is a pending line
        if (pendingLineStartPoint != null) {
            //draw temporary line from pendingLineStartPoint to snap position
            ctx.beginPath();
            ctx.moveTo(pendingLineStartPoint.x, pendingLineStartPoint.y);
            ctx.lineTo(snapX, snapY);
            ctx.closePath();
            ctx.strokeStyle = 'teal';
            ctx.stroke();
        }
    } else if (currentTool == 'delete-line') {
        
    } else if (currentTool == 'select-line') {
        
    } else if (currentTool == 'move-vertex') {
        if (selectedVertex == null && snapType == 'vertex') {
            //draw dot at snap position (potentially selectable vertex)
            ctx.beginPath();
            ctx.arc(snapX, snapY, 2, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fillStyle = 'teal';
            ctx.fill();
        }
        if (selectedVertex != null) {
            //draw dot at snap position (potential new vertex position)
            ctx.beginPath();
            ctx.arc(snapX, snapY, 2, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fillStyle = 'teal';
            ctx.fill();
        }
    }
}

function mouseClick(e) {
    if (currentTool == 'draw-line') {
        if (pendingLineStartPoint != null) {
            //complete pending line
            saveGrid(); //save the grid first
            lineSegments.push({
                p1:pendingLineStartPoint,
                p2:{x:snapX,y:snapY},
                selected:false,
                hover:false}
            );
        }
        //start pending line
        pendingLineStartPoint = {x:snapX,y:snapY};
    } else if (currentTool == 'delete-line') {
        //delete mouse hover line
        saveGrid(); //save the grid first
        var mouseHoverLine = -1;
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                mouseHoverLine = i;
                break;
            }
        }
        if (mouseHoverLine != -1) {
            lineSegments.splice(mouseHoverLine,1);     
        }
    } else if (currentTool == 'select-line') {
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                lineSegments[i].selected = !lineSegments[i].selected;
                lineSegments[i].hover = false;
            }
        }
    }
    drawGrid();
}

function rightClick() {
    if (currentTool == 'draw-line') {
        //clear pending line
        pendingLineStartPoint = null;
    }
}

function mouseDown() {
    if (currentTool == 'move-vertex') {
        if (snapType == 'vertex') {
            selectedVertex = {x:snapX,y:snapY};
            console.log('mousedown - vertex selected for move');
        }
    }
}

function mouseUp() {
    if (currentTool == 'move-vertex') {
        if (selectedVertex != null) {
            //permanently apply vertex move
            saveGrid(); //save the grid first
            for (var i=0; i<lineSegments.length; ++i) {
                var p1 = lineSegments[i].p1;
                var p2 = lineSegments[i].p2;
                if (p1.x == selectedVertex.x && p1.y == selectedVertex.y) {
                    p1.x = snapX;
                    p1.y = snapY;
                } else if (p2.x == selectedVertex.x && p2.y == selectedVertex.y) {
                    p2.x = snapX;
                    p2.y = snapY;
                }
            }
            selectedVertex = null;
            console.log('mouseup - vertex move complete');
        }
    }
}

function clickIE() {
    if (document.all) {
        return false;
    }
} 
function clickNS(e) {
    if (document.layers || (document.getElementById && !document.all)) 
    { 
        if (e.which==2 || e.which==3) {
            rightClick();
            return false;
        }
    }
}
if (document.layers) {
    document.captureEvents(Event.MOUSEDOWN);
    document.onmousedown = clickNS;
} else {
    document.onmouseup = clickNS;
    document.oncontextmenu = clickIE;
}
document.oncontextmenu = function() {return false;};

function showHideGridBtnClicked() {
    if ($(this).val() == "Hide Grid") {
        isGridVisible = false;
        $(this).val("Show Grid");
    } else {
        isGridVisible = true;
        $(this).val("Hide Grid");
    }
    drawGrid();
}

function selectAllBtnClicked() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSegments[i].selected = true;
    }
    drawGrid();
}

function selectNoneBtnClicked() {
    clearSelectedLines();
    drawGrid();
}

function deleteSelectedBtnClicked() {
    var survivingLines = [];
    for (var i=0; i<lineSegments.length; ++i) {
        if (!lineSegments[i].selected) {
            survivingLines.push(lineSegments[i]);
        }
    }
    lineSegments = survivingLines;
    drawGrid();
}

function clearSelectedLines() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSegments[i].selected = false;
    }    
}

function toolRadioChanged() {
    var id = this.id;
    currentTool = id;
    pendingLineStartPoint = null;
    if (id == 'delete-line' || id == 'draw-line') {
        //clearSelectedLines(); //not sure if this is desirable
    }
    drawGrid();
}

function initSnapOptionsUI() {
    //$("#snapOptions").buttonset();
    $("#snapToGrid").prop('checked',snapToGrid);
    $("#snapToVertices").prop('checked',snapToVertices);
    $("#snapToEdges").prop('checked',snapToEdges);
    $("#snapToGrid").change(function() {
        snapToGrid = $(this).prop('checked');
    });
    $("#snapToVertices").change(function() {
        snapToVertices = $(this).prop('checked');
    });
    $("#snapToEdges").change(function() {
        snapToEdges = $(this).prop('checked');
    });
}

function srcTxtKeyPress(e) {
    if (e.keyCode == 13) {
        var data = eval('('+$(this).val()+')');
        lineSegments = data['lineSegments'];
        drawGrid();
    }
};

function undo() {
    //cannot undo if history is empty
    if (history.length > 0) {
        lineSegments = history.pop()['lineSegments'];
    } else {
        lineSegments = [];
    }
    drawGrid();
}

function redo() {
    console.log('not implemented');
}

$(function() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    drawGrid();
    canvas.addEventListener('mousemove', mouseMove, false);
    canvas.addEventListener('click', mouseClick, false);
    //$('input.Btn').button();
    $('#showHideGridBtn').click(showHideGridBtnClicked);
    $('#selectAllBtn').click(selectAllBtnClicked);
    $('#selectNoneBtn').click(selectNoneBtnClicked);
    $('#deleteSelectedBtn').click(deleteSelectedBtnClicked);
    $('#undoBtn').click(undo);
    //$("#radio").buttonset();
    $("input.ToolRadio").change(toolRadioChanged);
    initSnapOptionsUI();
    $('#canvas').mousedown(mouseDown);
    $('#canvas').mouseup(mouseUp);
    $('#srcTxt').keypress(srcTxtKeyPress);
    $(document).keydown(function(e)
    {
        if (e.keyCode == KEY_CTRL) {
            ctrlDown = true;
        } else if (ctrlDown && e.keyCode == KEY_Z) {
            undo();
        } else if (ctrlDown && e.keyCode == KEY_Y) {
            redo();
        }
    }).keyup(function(e)
    {
        if (e.keyCode == KEY_CTRL) ctrlDown = false;
    });
});
</script>
<style type="text/css">
#canvas {
    border: 1px solid #ddd;
    position: relative;
}
input.BtnSelected {
    background-color: #888;
}
input, label {
    font-family: Calibri;
}
</style>
</head>
<body>
<div style="text-align: center">
<canvas id="canvas" width="640" height="480"></canvas>
<form>
	<div id="radio">
		<input type="radio" class="ToolRadio" name="tool-radio" id="draw-line" checked="checked" /><label for="draw-line">Draw Line</label>
		<input type="radio" class="ToolRadio" name="tool-radio" id="select-line" /><label for="select-line">Select Line</label>
        <input type="radio" class="ToolRadio" name="tool-radio" id="delete-line" /><label for="delete-line">Delete Line</label>
        <input type="radio" class="ToolRadio" name="tool-radio" id="move-vertex" /><label for="delete-line">Move Vertex</label>
	</div>
    <input type="button" class="Btn" value="Hide Grid" id="showHideGridBtn"/>
    <input type="button" class="Btn" value="Select All" id="selectAllBtn"/>
    <input type="button" class="Btn" value="Select None" id="selectNoneBtn"/>
    <input type="button" class="Btn" value="Delete Selected" id="deleteSelectedBtn"/>
    <input type="button" class="Btn" value="Undo" id="undoBtn"/>
    <div id="snapOptions">
        <input type="checkbox" id="snapToGrid" /><label for="snapToGrid">Snap to Grid</label>
        <input type="checkbox" id="snapToVertices" /><label for="snapToVertices">Snap to Vertices</label>
        <input type="checkbox" id="snapToEdges" /><label for="snapToEdges">Snap to Edges</label>
    </div>
    <textarea rows="10" cols="80" id="srcTxt"></textarea>
</form>
</div>
</body>
</html>