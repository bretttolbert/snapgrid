<!DOCTYPE html>
<html>
<head>
<title>snapgrid</title>
<meta charset="utf-8" />
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
<script type="text/javascript">
/**
 * snapgrid
 * https://github.com/bretttolbert/snapgrid
 */
 //snapgrid global variables
var canvas; //html5 canvas element
var ctx; //canvas drawing context
var CELL_SIZE = 16; //size of each grid cell
var mouseX, mouseY; //coordinate of most recent mouse position
var snapX, snapY; //coordinate of grid vertex which is closest to cursor position
var lineSegments = []; //the list of all existing line segments (point pairs)
var currentTool = 'line-tool';
var isGridVisible = true;

//line-tool variables
var pendingLineStartPoint = null; //used by the line-tool

/** 
 * Responsible for drawing the grid and all existing line segments
 */
function drawGrid() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (isGridVisible) {
        ctx.strokeStyle = '#ddd';
        for (var x=CELL_SIZE; x<canvas.width; x+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,canvas.height);
            ctx.stroke();
        }
        for (var y=CELL_SIZE; y<canvas.width; y+=CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(canvas.width,y);
            ctx.stroke();
        }
    }
    for (var i=0; i<lineSegments.length; ++i) {
        var p1 = lineSegments[i].p1;
        var p2 = lineSegments[i].p2;

        //draw dot for p1
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();
        
        //draw dot for p2
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();
        
        //draw line
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y)
        ctx.lineTo(p2.x, p2.y);
        if (lineSegments[i].hover && (currentTool == 'delete-tool' || currentTool == 'select-tool')) {
            ctx.strokeStyle = 'teal';
        } else if (lineSegments[i].selected) {
            ctx.strokeStyle = 'blue';
        } else {
            ctx.strokeStyle = 'black';
        }
        ctx.stroke();
    }
}

/**
 * Detects mouse hover over any existing line segment
 */
function updateMouseHoverLine() {
    for (var i=0; i<lineSegments.length; ++i) {
        lineSeg = lineSegments[i];
        lineSeg.hover = false;
        /*
        //if cursor is within snap range of one vertex of a line exactly
        if ((snapX == lineSegments[i].p1.x && snapY == lineSegments[i].p1.y)
         || (snapX == lineSegments[i].p2.x && snapY == lineSegments[i].p2.y)) {
            selectedLines.push(i);
            //highlight this line
            ctx.beginPath();
            ctx.moveTo(lineSegments[i].p1.x, lineSegments[i].p1.y);
            ctx.lineTo(lineSegments[i].p2.x, lineSegments[i].p2.y);
            ctx.closePath();
            ctx.strokeStyle = "red";
            ctx.stroke();
        }
        */
        //determine if cursor position is on or very near a line
        var TOLERANCE = CELL_SIZE/2;

        //calculate slope of the line, in case of vertical line divide by zero like a boss
        var m = (lineSeg.p2.y - lineSeg.p1.y)
              / (lineSeg.p2.x - lineSeg.p1.x);
        var x,y;
        if (Math.abs(m) == Infinity) {
            x = mouseX;
            y = mouseY;
        } else {
            //calculate what y of the line would be if x were exactly mouseX
            y = m * (mouseX - lineSeg.p1.x) + lineSeg.p1.y;
            //calculate what x of the line would be if y were exactly mouseY
            x = (mouseY - lineSeg.p1.y) / m + lineSeg.p1.x;
        }
        //are calculated values within tolerance?
        if (Math.abs(y - mouseY) < TOLERANCE && Math.abs(y - mouseY) < TOLERANCE) {
            //mouse pos is (approximately) on the line but is it within the line segment?
            //determine extrema of the line segment
            var minX = Math.min(lineSeg.p1.x, lineSeg.p2.x);
            var minY = Math.min(lineSeg.p1.y, lineSeg.p2.y);
            var maxX = Math.max(lineSeg.p1.x, lineSeg.p2.x);
            var maxY = Math.max(lineSeg.p1.y, lineSeg.p2.y);
            if (   (mouseX >= minX || minX - mouseX < TOLERANCE)
                && (mouseY >= minY || minY - mouseY < TOLERANCE)
                && (mouseX <= maxX || mouseX - maxX < TOLERANCE)
                && (mouseY <= maxY || mouseY - maxY < TOLERANCE)) {
                lineSeg.hover = true;
                return;
            }
        }
    }
}

/**
 * Determines grid vertex closest to mouse position
 */
function updateSnapPos() {        
    //determine first vertical gridline with x greater than mouseX
    for (snapX=CELL_SIZE; snapX<=canvas.width && snapX<mouseX; snapX+=CELL_SIZE) { }
    //snap to previous vertical gridline if mouseX is less than half way there
    if ((snapX - mouseX) > CELL_SIZE / 2) {
        snapX -= CELL_SIZE;
    }

    //determine first horizontal gridline with y greater than mouseY
    for (snapY=CELL_SIZE; snapY<=canvas.height && snapY<mouseY; snapY+=CELL_SIZE) { }
    //snap to previous horizontal gridline if mouseY is less than half way there
    if ((snapY - mouseY) > CELL_SIZE / 2) {
        snapY -= CELL_SIZE;
    }
    
    /*
    //highlight vertical gridline
    ctx.strokeStyle = 'yellow';
    ctx.beginPath();
    ctx.moveTo(snapX,0);
    ctx.lineTo(snapX,canvas.height);
    ctx.closePath();
    ctx.stroke();

    //highlight horizontal gridline
    ctx.strokeStyle = 'yellow';
    ctx.beginPath();
    ctx.moveTo(0,snapY);
    ctx.lineTo(canvas.width,snapY);
    ctx.closePath();
    ctx.stroke();
    */
}

function mouseMove(e) {
    if(e.offsetX) {
        mouseX = e.offsetX;
        mouseY = e.offsetY;
    }
    else if(e.layerX) {
        mouseX = e.layerX;
        mouseY = e.layerY;
    }
    drawGrid();
    updateSnapPos();
    updateMouseHoverLine();
    
    if (currentTool == 'line-tool') {
        //draw dot at closet grid vertex
        ctx.beginPath();
        ctx.arc(snapX, snapY, 2, 0, Math.PI*2, true); 
        ctx.closePath();
        ctx.fillStyle = 'teal';
        ctx.fill();
        
        //draw temporary line from pendingLineStartPoint to snap position
        if (pendingLineStartPoint != null) {
            ctx.beginPath();
            ctx.moveTo(pendingLineStartPoint.x, pendingLineStartPoint.y);
            ctx.lineTo(snapX, snapY);
            ctx.closePath();
            ctx.strokeStyle = 'teal';
            ctx.stroke();
        }
    } else if (currentTool == 'delete-tool') {
        
    } else if (currentTool == 'select-tool') {
        
    }
}

function mouseClick(e) {
    if (currentTool == 'line-tool') {
        if (pendingLineStartPoint != null) {
            //complete pending line
            lineSegments.push({
                p1:pendingLineStartPoint,
                p2:{x:snapX,y:snapY},
                selected:false,
                hover:false}
            );
            pendingLineStartPoint = {x:snapX,y:snapY};
        }
        //start pending line
        pendingLineStartPoint = {x:snapX,y:snapY};
    } else if (currentTool == 'delete-tool') {
        //keep this old logic around. we can use it for a 'delete selected' button
        /*
        var survivingLines = [];
        for (var i=0; i<lineSegments.length; ++i) {
            var selected = false;
            for (var j=0; j<selectedLines.length; ++j) {
                if (selectedLines[j] == i) {
                    selected = true;
                }
            }
            if (!selected) {
                survivingLines.push(lineSegments[i]);
            }
        }
        lineSegments = survivingLines;
        */
        //delete mouse hover line
        var mouseHoverLine = -1;
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                mouseHoverLine = i;
                break;
            }
        }
        if (mouseHoverLine != -1) {
            lineSegments.splice(mouseHoverLine,1);     
        }
    } else if (currentTool == 'select-tool') {
        for (var i=0; i<lineSegments.length; ++i) {
            if (lineSegments[i].hover) {
                lineSegments[i].selected = !lineSegments[i].selected;
                lineSegments[i].hover = false;
            }
        }
    }
    drawGrid();
}

function mouseDown(e) {
	var rightclick;
	if (!e) var e = window.event;
	if (e.which) rightclick = (e.which == 3);
	else if (e.button) rightclick = (e.button == 2);
	alert('Rightclick: ' + rightclick); // true or false
}

function rightClick() {
    if (currentTool == 'line-tool') {
        //clear pending line
        pendingLineStartPoint = null;
    }
}

function clickIE() {
    if (document.all) {
        return false;
    }
} 
function clickNS(e) {
    if (document.layers || (document.getElementById && !document.all)) 
    { 
        if (e.which==2 || e.which==3) {
            rightClick();
            return false;
        }
    }
}
if (document.layers) {
    document.captureEvents(Event.MOUSEDOWN);
    document.onmousedown = clickNS;
} else {
    document.onmouseup = clickNS;
    document.oncontextmenu = clickIE;
}
document.oncontextmenu = function() {return false;};

function showHideGridBtnClicked() {
    if ($(this).val() == "Hide Grid") {
        isGridVisible = false;
        $(this).val("Show Grid");
    } else {
        isGridVisible = true;
        $(this).val("Hide Grid");
    }
    drawGrid();
}

function toolRadioChanged() {
    var id = this.id;
    currentTool = id;
    pendingLineStartPoint = null;
    if (id == "delete-tool") {
        for (var i=0; i<lineSegments.length; ++i) {
            lineSegments[i].selected = false;
        }
    }
}

$(function() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    drawGrid();
    canvas.addEventListener('mousemove', mouseMove, false);
    canvas.addEventListener('click', mouseClick, false);
    $('input.Btn').button();
    $('#showHideGridBtn').click(showHideGridBtnClicked);
    $( "#radio" ).buttonset();
    $("input.ToolRadio").change(toolRadioChanged);
});
</script>
<style type="text/css">
#canvas {
    border: 1px solid #ddd;
    position: relative;
}
input.BtnSelected {
    background-color: #888;
}
</style>
</head>
<body>
<div style="text-align: center">
<canvas id="canvas" width="640" height="480"></canvas>
<form>
    <input type="button" class="Btn" value="Hide Grid" id="showHideGridBtn"/>
	<span id="radio">

		<input type="radio" class="ToolRadio" name="tool-radio" id="line-tool" checked="checked" /><label for="line-tool">Line Tool</label>
		<input type="radio" class="ToolRadio" name="tool-radio" id="select-tool" /><label for="select-tool">Select Tool</label>
        <input type="radio" class="ToolRadio" name="tool-radio" id="delete-tool" /><label for="delete-tool">Delete Tool</label>
	</span>
</form>
</div>
</body>
</html>